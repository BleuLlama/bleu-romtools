
----------------------------------------
                      Scott's Z80 Kernel
                            2007-July-07
                        yorgle@gmail.com
                 http://umlaultllama.com

----------------------------------------

Table Of Contents:
	1.0 Overview
	2.0 License
	3.0 Files
	4.0 Building
	    4.1 MAME hacking
	5.0 Design
	    5.1 Adding A Task
	    5.2 Exploitation (using these games in your multigame kit)
	6.0 Reference


----------------------------------------
                            1.0 Overview

	This is Scott's Z80 kernel.  It's not meant to be a complete
	OS, but rather a simple task launcher with coin-drop
	capability.  That is to say that it is a good system wrapper
	with a simple menu system meant to be used to launch a few
	different mini games, support coin-based systems (arcade
	use).  It provides some simple system maintenace routines
	as well as various graphics and game support functions that
	are useful to a game programmer.

	It also provides the framework to let you create a collection
	of games in a single romset.


----------------------------------------
                             2.0 License

	This work would be licensed under the Creative Commons
	Attribution-Noncommercial-Share Alike 2.5 License, if it
	could be. To view a copy of this license, visit

	    http://creativecommons.org/licenses/by-nc-sa/2.5/

	or send a letter to Creative Commons, 543 Howard Street,
	5th Floor, San Francisco, California, 94105, USA.


	But since the Creative Commons License is not supposed to
	be used for software, this is instead released under a
	Freeware license.


	Do what you like with this, feel free to generate derivative
	works.  I am not responsible for anything this code might
	do, or it not doing something that it is supposed to do.
	Please, don't sell it without contacting me to work out
	details about doing so.

	Scott is not responsible for any lost revenue or unregistered
	coin-drops.  Use this at your own risk.  On the other hand,
	please feel free to modify, augment, and improve it... just
	send any changes back to Scott.


----------------------------------------
                               3.0 Files

This project contains a few subprojects:

	Core/
		This is the core portion of the task switcher and such.
		It handles simple graphics, input, simple sounds and such

	Tasks/
		Various tasks to be run on the core (single or multi)

		MusicPlayer	- pattern-based music playback
		MoviePlayer	- an experimental RLE video playback mechanism
		PTUI		- A simple GUI system
		GameMenu	- starts various games, handles coins, settings
		QuadBlok	- game: tetris clone
		Absurd		- game: silly strategy game

	Graphics/
		The Graphics.  Contains a few files and dirs:
		msp_1.pcx, msp_1c.pcx	bank 1 graphics source
		msp_2.pcx, msp_2c.pcx	bank 2 graphics soource

	BaseRoms/
		Initial rom files, zeroed blanks:
			0000.bin 8000.bin 5e 5f

		as well as the support proms: (customized)
			82s123.7f 82s126.4a
			82s126.1m 82s126.3m

	Aux/
		Contains auxiliary files: Turaco .ini, genroms .roms

	mspac2/
	mspacmab/
		where the files get generated into. (generated by the makefile)

	More about this layout in section 5.0 below.

----------------------------------------
                            4.0 Building

	To build this, you will need a few tools:

	- Turaco CL 0.8  - command-line version of the "Turaco" tool
		generates graphics roms from PCX files and vice-versa
		http://umlautllama.com/project.php?ShortName=TuracoCL

	- Genroms 1.8 
		converts .ihx files to Arcade Rom Images
		http://umlautllama.com/project.php?ShortName=Genroms

	- asz80  - ASxxxx Assembler V0.1.50c
	- aslink - ASxxxx Linker V01.50
		These are a part of the zcc 0.96 package, containing a
		z80 C compiler and assembler.  The compiler adheres
		to the K&R C style syntax, so be careful of ANSI-isms.
		my mirror: http://umlautllama.com/projects/pacdocs/#tools
		I only use the included assembler, with some tweaks.

	- Gnu build tools (gmake, etc.)

	Once all of these tools are installed, properly configured
	and working on your computer, you should be able to just
	type 'make' in the main directory, and it should "just work"

		4.1 MAME Hacking

	For testing, you will probably want to add 'MAME' into the mix.
		http://www.mame.net/
	For proper use, you will probably want to add a game driver
	to the MAME source.  Add a driver named "mspac2".  ("2"
	means "two rom version".)  This is a mspac bootleg,
	essentially.  There are some bootlegs (Yenox and Falcon for
	example) that use this configuration, but their "two" roms
	are contained on one eprom.

	There is also support in the makefile for using the standard
	6-rom mspac bootleg ("boot1", "boot2", "boot3", etc).  Just
	change the ROMSET define to "mspacmab" rather than "mspac2".
	For smaller sets, "mspacmab" will be plenty, but if you
	need the extra 8kb of rom space, "mspac2" is for you.

	The two "mspac2" roms contain data for memory addresses:
		0000-3FFF
	and
		8000-BFFF

	In the bootlegs, these are consecutive in one 32k rom.  For our
	purposes, to make things easier, we will store them in two 
	separate 16k files:
		0000-3FFF	will be in 	0000.bin
		8000-BFFF	will be in	8000.bin

	NOTE: The following works on MAME 0.77.1  Other versions of 
	MAME will most likely be different.  The important three steps are:
		1. Adding the driver to the list (drivers.c)
		2. Adding the ROM list to have the two roms defined (pacman.c)
		3. Adding the game driver to the list in (pacman.c)


	You should be able to easily add a driver to the list in src/drivers.c:
	
		DRIVER( mspac2 )

	Then in src/drivers/pacman.c:
	
		ROM_START( mspac2 )

		/* 64k for code */
		ROM_REGION( 0x10000, REGION_CPU1, 0 )
		ROM_LOAD( "0000.bin",      0x0000, 0x4000, CRC(0) SHA1(0) )
		ROM_LOAD( "8000.bin",      0x8000, 0x4000, CRC(0) SHA1(0) )
		
		/* character rom */
		ROM_REGION( 0x1000, REGION_GFX1, ROMREGION_DISPOSE )
		ROM_LOAD( "5e",           0x0000, 0x1000, CRC(0) SHA1(0) )

		/* sprite rom */
		ROM_REGION( 0x1000, REGION_GFX2, ROMREGION_DISPOSE )
		ROM_LOAD( "5f",           0x0000, 0x1000, CRC(0) SHA1(0) )
		
		/* color proms */
		ROM_REGION( 0x0120, REGION_PROMS, 0 )
		ROM_LOAD( "82s123.7f",    0x0000, 0x0020, CRC(0) SHA1(0) )
		ROM_LOAD( "82s126.4a",    0x0020, 0x0100, CRC(0) SHA1(0) )
		
		/* sound PROMs */
		ROM_REGION( 0x0200, REGION_SOUND1, 0 )
		ROM_LOAD( "82s126.1m",    0x0000, 0x0100, CRC(0) SHA1(0) )
		ROM_LOAD( "82s126.3m",    0x0100, 0x0100, CRC(0) SHA1(0) )
		ROM_END 

	And finally, adding in the game to the list in the bottom of pacman.c
		GAME( 2004, mspac2, mspacman, pacman,   mspacman, 0,
				ROT90,  "hack", "two-rom mspac" )

	Your milage may vary.


	NOTE: One of the makefile targets will run MAME in debug
	mode, so that you can step through the code, monitor
	registers, etc... It should be noted that the screen is
	intentionally rotated weird.  This is necessary for xmame
	on OS X, otherwise it will not work.  Go figure.


	NOTE: If you are getting this via the mixed rom-image/source
	package from the website, (denoted with "M.zip" in the
	filename) you will need to do other things to get this to
	build, like the creation of a build script.  The full source
	package contains individual .asm files, game graphics in
	PCX format, a Makefile, more documentation and other goodies.
	This other package is available upon request.

----------------------------------------
                              5.0 Design

	The basic design can be gleaned from the file layout.

	Core/ contains the core of the engine.   This consists of
	things like the timer maintenance, at scheduling, coin
	detection, main menu selection, dip switch maintenance,
	test mode, as well as graphical routines that draw text and
	RLE encoded graphics to the screen.

	Tasks/ contains a file "tasklist.asm" as well as subdirectories
	containing the various games and such that the menu system
	can launch as well as the music player, PacTracker.

	The tasklist.asm contains a list of pointers to task
	structures, as well as the functions that dereference through
	those to get the current task's title, jump into various
	entry points and so on.

	The layout of those task structures is defined in a comment
	in that file, and should be referenced for creating your
	own tasks.  To add a task to the menu system, you need to
	just put in an entry into the "tasklist:" at the top of
	that file, and add your .asm files into the Makefile.  

	The NTASKS define should be right below the last task in
	the list.  If there is only one task on the list, the
	left/right arrows will not be displayed in the menu.  The
	menu system will automatically know how many entries to
	allow the user to scroll through based on the location of
	that NTASKS definition.

	The entries (as of the writing of this document) in this
	structure are as follows:

	All of the entries are 16 bit pointers, ".word"  to various
	things.

	NOTE: In case you are unfamiliar with it, a "Pascal string"
	consists of one byte denoting the string length, followed
	by the string itself.  "C string"s are null-terminated.
	Pascal strings aren't necessarily so.  For example, the
	pascal string:
		10, "Hello, World"
	Is equivalent to the C-String:
		"Hello, Wor"

	index 0: TITLE - pascal string
		This is the title displayed in the menu.
		It should be 17 characters wide

	index 2: DESC1 - pascal string
	index 4: DESC2 - pascal string
		These two lines are displayed under the title in the menu.
		They both should be 21 characters wide.

	index 6: ATT0 - function pointer
		This gets called at the beginning of the attract sequence.
		That is to say that when the user navigates to this
		item in the menu, this will get called once, as
		soon as the screen is drawn and has its initial
		update with the new information.  This is a good
		place to put one-time initialization of animations
		for the menu screen.

	index 8: ATT - function pointer
		This gets polled once each time through the loop.
		The menu code will poll various things (coin drops,
		user input, sound) as well as this function.  This
		should take care of updating and animating sprites
		for the attract sequence.

	index 10: GAME0 - function pointer
		This gets called at the beginning of the game sequence.
		After the user has dropped their coins and pressed "Start",
		this will get called once and only once.

	index 12: GAME - function pointer
		This gets called once each time through the loop.
		The core will poll various things (like coin drops)
		as well as this function.  This is where your game 
		does everything it needs to do.
		Don't forget to only do one set of things and
		relinquish control, so as to not stall the system.

	index 14: CREDITS - number of credits needed to play
		The user will only be able to press 'start' if 
		this number of credits have been entered.  Set
		to 0 if freeplay is desired for this game slot

	index 15: VARIANTS - list of variant names
		This points to a structure with the following layout:
		First, a single byte stating how many strings follow
		Next, a pointer to each pascal string.  Each string
		should be 17 bytes wide, so that they overwrite
		eachother properly on the screen.

	The basic concept is that the core of the system will poll
	various things at runtime to do a kind of cooporative
	multitasking.  The Task's GAME loop can take over the system
	if you really want, for example, but it would inhibit the
	use of the core coin-drop counter, timers and such.


	It should be noted also, that the assembler (or perhaps the
	linker) has an 8 character limit for labels.  You can have
	longer lables, but everything after the 8th character is
	ignored.  So, for example, the following two labels are the
	same in the environment:

		StartTask1:
		StartTask2:

	And likewise, these are not:

		Task1Start:
		Task2Start:

	Each game can look at a few global variables which are set
	by the menu system: 
		credits	- number of credits left (informational)
		variant - which variant was selected.  None or first is 0
		nplayers - set to 1 if P1 start pressed, 2 if P2 start pressed
		dipBases - number of bases per play
		basesLeft - number of lives left for the player
		difficulty - is the dipswitch set for hard or normal?
	Please refer to ram.asm for more detailed info.

	
	5.1 Adding a Task

	This is a step by step howto on adding another task to the
	kernel system.

	5.1.1. Make a new directory in Tasks for your new task
		mkdir Tasks/BunnyBlaster

	5.1.2. Copy over the example task source to this directory
		cp Tasks/Example/example.asm Tasks/BunnyBlaster/bunny.asm

	5.1.3. rename the "xx" stuff in the "bunny.asm" to something appropriate
		ie,  xxTask -> bunnyTask  and so on

	5.1.4. Add it to the Makefile.  Refer to the existing tasks
	       on how to put in the hooks to do this.  For example,
	       look at how "ABSURD" defines the included files, and
	       then TASKS inlcudes ABSURD.

	5.1.5. Add the new task into the task structures as defined
	       in Tasks/tasklist.asm  In that file, you will see a
	       label "tasklist" There are a few tasks in there,
	       then a label NTASKS.  Every task pointer listed
	       between that and "tasklist" above it will appear in
	       the menu.  So, drop your pointer to the new task in
	       that range.

		tasklist:
			.word	absurdTask
			.word	quadblokTask
			.word	bunnyTask
			NTASKS = .-tasklist
			.word	ssaveTask
			....

	5.1.6. Build it.  It should build and run fine.

	5.1.7. From here, you just need to fill in that stub with
	       your attract sequence, game engine, and so on.  Refer
	       to section 6.0 of this document, which aspires to
	       document the Game Kernel API and available functions
	       that you can use in your task.

	5.1.8. You might want to build the "listing" version of the
	       source blob.

		make listing

	       This will help you find bad pointers, jr's too far,
	       etc.

	5.1.9. Some important things you should use:

		functions:

		call Mo_death	; triggers the "death sequence" state

		variables:

		variant		; which game variant the user selected
				; #0x00 for first, etc
		nplayers	; the number of players the user selected
				; #0x01 for single player, #0x02 for 2 player
		difficulty	; diffNORM or diffHARD (dipswitch)
		

	Test often.  Test extensively.  Test on real hardware.


	5.2 Exploitation

	NOTE: you may need to refer to the listing or source code
	      modules themselves to know the addresses to hook into,
	      since the following descriptions use the names that
	      the sourcecode uses, and not their rom positions.

	If you are going to hook these games into your own menu
	system, bypassing the built in one, you will need to be
	sure a few things are set before the engine is happy with
	things:

	First, setup these variables/ram:
		variant - the variant number you want to run
			   #0x00 for none or the first one on the list
		nplayers - should be #0x01 or #0x02 
		difficulty - set to diffNORM or diffHARD

	That should be all that is needed to kickstart the game
	system.  You also might want to clear out the user ram space
	as well, but that's not really necessary.

	Some games display the number of credits, or use buy-in to
	let the users continue.  You will probably want to set
	"credits" to be the number of credits currently in the
	system.  This system assumes one coin per credit, and ignores
	the dipswitch settings for coins-credits conversions.

	You can also effectively disable buy-in if you'd like by
	replacing the code in Mo_buyin with a jump to Mo_death, or
	even easier, replace the return at the end of the Mo_buyin
	routine with a nop.

	To start the game, you should now make a call to Mo_gameplay,
	to set up the important stuff for the game mode, screen and
	sprite clearing and such.

	You will then need to poll the system by using the loop
	contained in mainLoop.  You can just jump to that routine
	to accomplish this.

	To hook back into your menu system, Dave, you'll want to
	set the code in .end_Death to point to your "reset the
	system" routine.  That gets called once the person is out
	of lives, and not wanting to continue.  It currently calls
	Mo_att to re-enable attract mode, but it's fine to change
	banks, reset the game system, whatever at that point.

	Happy hacking!


	6.0 Reference

	This section will list  all that the core functions have
	to offer you and your task.  Refer to the source file and
	the function names listed for more information.

	Obviously, there are more functions in the core than what
	is listed here, these are just the ones you should look
	for.  There are additional calls which get used by the
	core for you.

	You should reference "hardware.asm" for the various addresses,
	available flags, bits, predefined values, colors and so on.

	Also, check "settings.asm" for the debug display flag
	(DEBUG), and preset values for screensaver timeout (SSTIMEOUT)
	as well as the amount of time that the death animation is
	on for (DEATHTIME) and the approximate time for a second
	(ONESECOND).

	6.0.1 User Input
		The "Get" functions will tell you if the user pressed
		the input in a certain way, and then released.
		These are maintained with an internal counter, and
		can be reset with the "inputclear" function.

		On all of these, if the button is/has been pressed,
		A will contain #0x01, otherwise #0x00

		Mix-and-matching the "Get" with the "Is" functions
		below might have odd results.

		"Get" will be certain to get input presses, whereas
		"Is" may miss one, if the button was pressed and
		released between calls to the "Is" function.  "Get"
		functions get checked at interrupt time, at 60 times
		prer second.  "Is" functions get checked only when
		the function is called.

		input.asm: Get1Start - player 1 start button was pressed
		input.asm: Get2Start - player 2 start button was pressed

		input.asm: Get1Up - player 1 pushed stick "up"
		input.asm: Get1Down - player 1 pushed stick "down"
		input.asm: Get1Left - player 1 pushed stick "left"
		input.asm: Get1Right - player 1 pushed stick "right"

		input.asm: Get2Up - player 2 pushed stick "up"
		input.asm: Get2Down - player 2 pushed stick "down"
		input.asm: Get2Left - player 2 pushed stick "left"
		input.asm: Get2Right - player 2 pushed stick "right"

		The "Is" functions will return the current state
		of the requested button. 

		input.asm: Is1Start - player 1 start button is down 
		input.asm: Is2Start - player 2 start button is down 

		input.asm: Is1Up - player 1 joystick is "up"
		input.asm: Is1Down - player 1 joystick is "down"
		input.asm: Is1Left - player 1 joystick is "left"
		input.asm: Is1Right - player 1 joystick is "right"

		input.asm: Is2Up - player 2 joystick is "up"
		input.asm: Is2Down - player 2 joystick is "down"
		input.asm: Is2Left - player 2 joystick is "left"
		input.asm: Is2Right - player 2 joystick is "right"

	6.0.1 Memory and Screen Clearing
		Your task can start using ram at the address defined
		in USERRAM, as seen in "ram.asm".  Don't touch
		anything below that, and be careful of things too
		long, since you will eventually run into the stack
		ram.

		memset.asm: memset256 - set a block of up to 256 bytes of ram
		memset.asm: memsetN - set N blocks of 256 bytes of ram

		clear.asm: cls - clear screen (character, color) ram

		clear.asm: clrspecial - clear the special registers
		clear.asm: clrsprite - clear the sprite ram
		clear.asm: clruser - clear user ram (DANGEROUS)
		clear.asm: clrtimer - reset the timer value

	6.0.1 Math
		bcdmath.asm: incBCDbc - increment a BCD digit
		bcdmath.asm: addToScore - add to a BCD value, for player score

		rand.asm: rand - get a random number, store it in A

		sine.asm: sine - get the sine (0..256) of A
		sine.asm: cosine - get the sine (0..256) of A

	6.0.2 Text
		All of these use the following format for drawing
		strings, more or less:
			B: X position
			C: Y position
			HL: The pascal string to render
		There are three regions of the screen that I established,
		Regions A and C are the top two and bottom two rows of text
		Region B is the bulk of the screen, in the middle.

		text.asm: textcenter - adjust text to be center justified
		text.asm: textright - adjust text to be right justified

		text.asm: putstrA - put a string to region A
		text.asm: putstrB - put a string to region B
		text.asm: putstrC - put a string to region C

		text.asm: prtXYbyteB - shoves out a byte to region B
		text.asm: prtBCDbyte - shoves out a byte to region A or C
		text.asm: prtBCDword - shoves out a word to region B
		text.asm: prtABCDword - shoves out a word to region A or C

		The following look at the screen as an array of 28 wide by
		32 tall, so 0,0 would be in the top left of region A
		0,1 is the second row of region A
		0,2 is actually the top left of region B

		text.asm: xy2offsB - XY (BC) in coords to screen offsset (HL)
		text.asm: xy2offsAC - XY (BC) in coords to screen offsset (HL)

	6.0.3 Sprites
		Due to the funky sprite hardware, this is a rough
		interface to said hardware.  Your milage may vary.
		Sprites stay on screen unless you tell them otherwise.
		Set the position to 0,0 for off-screen/turning them
		off.  The screen can be seen as a 256x256 pixel
		canvas.  The upper left of the sprite appears at
		the requested address.  Vertically, all of the
		[0..256] range is visible, and fits between the top
		two character rows, and the bottom two.  Horizontally,
		the leftmost and rightmost 32(?) positions are
		hidden off the edge of the screen.

		sprites.asm: sprite - draw a sprite onto the screen
		sprites.asm: dsprite - draw a sprite animation onto the screen

		The following two are useful for converting background
		to sprite positions:

		sprites.asm: addrAtXY - find screen addr of the XY position
		sprites.asm: XYAtAddr - find XY position for a screen addr

	6.0.4 RLE Stored Image Display
		rle.asm: rledraw - draw an RLE compressed image

	6.0.5 Timers
		The "at" timers should trigger a callback in your
		code that is very short.  usually, it should just
		set a flag in your code, to be checked during
		foreground processing.

		at.asm:	atSchedule - schedule timer number 1
		at.asm:	atDelta - schedule timer number 1
		at.asm: atClear - clear timer number 1

		at.asm:	at2Schedule - schedule timer number 2
		at.asm:	at2Delta - schedule timer number 2
		at.asm: at2Clear - clear timer number 2

		There also foreground sleep timers.  These will
		wait in the foreground for the expected duration.

		sleep.asm: sleep - sleep for BC ticks


	6.0.6 RST calls
		As you may or may not know, the RST calls are
		functions that can be called with a single opcode.
		They can be up to 8 bytes of code, making them
		perfect for pointer dereferencing and such like
		that - or just entry hooks for other functions.

		RST 00: hard reboot sequence (more ram clearing, etc)
		RST 08: soft reboot sequence
		RST 10: pointer dereferencing - HL = (HL+DE)
		RST 18: array retrieval - A = (HL[a])
		RST 20: unused
		RST 28: unused
		RST 30: unused
		RST 38: Timer interrupt - called once each frame

		The timer interrupt is used by the core system to
		check for "at" timer updates, clock timers, music
		updates, etc.  All code in this should be kept to
		a minimum, to prevent slowdown of "foreground" Task
		processing.


	6.0.k States and Variables

		You really shouldn't touch these, except for Mo_death.

		main.asm: Mo_ssaver - switch to screensaver mode
		main.asm: Mo_att - switch to attract mode
		main.asm: Mo_gameplay - switch to gameplay mode
		main.asm: Mo_death - switch to "user is dying" mode *
		main.asm: Mo_buyin - switch to "insert coins to continue" mode
		main.asm: Mo_test - switch into Testing supermode
		main.asm: Mo_endTest - switch out of Testing supermode
